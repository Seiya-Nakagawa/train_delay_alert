# 路線遅延通知システム 基本設計書

## 1. 概要

本ドキュメントは、「路線遅延通知システム 要件定義書」に基づき、システムの実現方式を定義する基本設計書です。本設計書は、後続の工程である詳細設計および実装のインプットとなることを目的とします。

## 2. システム構成

### 2.1. システム構成図

**【路線遅延通知】システム構成図.drawio**を参照

### 2.2. 利用技術・サービス

| 分類 | 技術・サービス名 | 目的 |
| :--- | :--- | :--- |
| **クラウド** | Amazon Web Services (AWS) | インフラ基盤 |
| **IaC** | Terraform Cloud | AWSリソースのコードによる管理と自動プロビジョニング |
| **CI/CD** | GitHub Actions | Lambda関数（アプリケーションコード）の自動デプロイ |
| **Webサービス** | GitHub Pages | 静的Webサイトのホスティング |

### 2.3. 実行環境・ライブラリ

| コンポーネント | 設定項目 | 設定値 | 備考 |
| :--- | :--- | :--- | :--- |
| **AWS Lambda** | ランタイム | Python 3.13 | |
| | Pythonライブラリ | boto3, requests | AWS SDK, HTTP通信 |

## 3. 機能設計

### 3.1. ユーザー設定機能

* **処理概要:** ユーザーがLINEのリッチメニューから設定用Webサイト（GitHub Pages）にアクセスし、LINEログイン認証を経て、遅延通知を受けたい路線を設定・更新する。設定内容はLambda経由でDynamoDBに保存される。
* **トリガー:** AWS Lambda Function URLへのHTTP POSTリクエスト
* **入力:**
  * **初回アクセス時:** LINE Platformから発行された認証コード (`authorizationCode`) を含むJSONオブジェクト。
  * **設定保存時:** LINEユーザーID (`lineUserId`) と登録路線IDのリスト (`routes`) を含むJSONオブジェクト。
* **処理シーケンス:**
    1. **ユーザー認証と情報取得:**
        a. Webサイトは、URLクエリパラメータに含まれる認証コードをLambdaに送信する。
        b. Lambda (`user_settings_lambda`) は、認証コードとLINEチャネル情報を使い、LINE PlatformのAPIを呼び出してアクセストークンを取得する。
        c. 取得したIDトークンを検証し、LINEユーザーIDを特定する。
        d. 特定したLINEユーザーIDを使い、DynamoDBのUsersテーブルから既存の設定情報を取得する。
        e. 取得した設定情報（または新規ユーザーの場合は空の設定）をWebサイトに返す。
    2. **設定の更新:**
        a. ユーザーがWebサイト上で設定を変更し、「保存」ボタンを押す。
        b. Webサイトは、現在の設定内容（LINEユーザーIDと路線IDリスト）をLambdaに送信する。
        c. Lambdaは、受け取った情報に基づき、DynamoDBのUsersテーブルのレコードを差分更新する。
        d. 更新が完了すると、S3上の`user-list.json`に対象のユーザーIDを追記（または新規作成）し、次回の遅延チェック処理の対象とする。
        e. （管理向け通知）SNSトピックに、ユーザーが更新された旨のメッセージを発行する。
* **出力:**
  * **情報取得時:** ユーザーの設定情報 (JSON)
  * **設定更新時:** 処理成功を示すステータスコード
* **エラー処理:** LINE API連携失敗、DynamoDBへの書き込み失敗時は、CloudWatch Logsにエラーを記録し、Webサイトにはエラーを示すステータスコードを返す。

### 3.2. 運行情報取得・遅延判定・通知機能

* **処理概要:** 定期的に起動し、ユーザーが登録した路線の遅延情報を取得・判定し、新規または更新された遅延情報を対象ユーザーにLINEで通知する。
* **トリガー:** Amazon EventBridge (5分間隔)
* **入力:** (なし。スケジュールによる自動実行)
* **処理シーケンス:**
    1. EventBridgeトリガーによりLambda (`check_delay_handler`) が起動。
    2. S3から`user-list.json`（設定変更があったユーザーのリスト）と`delay-messages.json`（前回通知した遅延情報のリスト）を読み込む。
    3. `user-list.json`に記載のユーザーIDに基づき、DynamoDBのUsersテーブルから各ユーザーの路線設定（路線IDリスト）を取得する。
    4. 全ユーザーの路線リストを統合し、ユニークな路線IDのリストを作成する。
    5. 公共交通オープンデータセンターAPIに問い合わせ、ユニークな路線リスト全体のリアルタイム運行情報を一括で取得する。
    6. 取得した運行情報と`delay-messages.json`の内容を比較し、新規または情報が更新された遅延を検知する。
    7. 新規・更新された遅延があった路線ごとに、以下の処理を行う。
        a. DynamoDBのUsersテーブルのGSI (`route-index`) をクエリし、その路線を登録している全ユーザーのLINEユーザーIDを抽出する。
        b. LINE Messaging APIのPush Message機能を使い、抽出した全ユーザーに遅延情報を記載したFlex Messageを送信する。
    8. 処理完了後、今回の遅延情報を`delay-messages.json`としてS3に保存し、次回の実行に備える。
    9. `user-list.json`をS3から削除し、次回の処理で同じユーザーを再度処理しないようにする。
* **出力:**
  * (遅延発生時) 対象ユーザーへのLINEプッシュ通知
  * (内部処理) S3オブジェクト (`delay-messages.json`, `user-list.json`) の更新・削除
* **エラー処理:**
  * 外部APIへの接続失敗、DynamoDBへのアクセス失敗、LINE APIへの通知失敗時は、CloudWatch Logsにエラーを記録し、処理を続行する。

### 3.3. 自動デプロイ機能

本システムでは、インフラストラクチャとアプリケーションのデプロイが、それぞれ独立したCI/CDワークフローによって自動化されている。

#### 3.3.1. インフラの自動プロビジョニング (Terraform Cloud)

* **処理概要:** `terraform`ディレクトリ配下のコードに対するプルリクエスト (PR) が`main`ブランチに対して作成されると、Terraform Cloudが自動的に`terraform plan`を実行し、変更計画を提示する。PRが`main`ブランチにマージされると、自動的に`terraform apply`が実行され、AWSリソースの変更が適用される。

* **トリガー:**

  * `terraform`ディレクトリ配下のコードに対するPR作成時: `terraform plan`

  * `terraform`ディレクトリ配下のコードを含むPRが`main`ブランチにマージされた時: `terraform apply`

* **処理シーケンス:**

    1. 開発者がTerraformコード (`.tf`ファイル) を変更し、`main`ブランチに対してPRを作成する。

    2. GitHubリポジトリと連携したTerraform CloudのWorkspaceがPR作成イベントを検知し、自動的に`terraform plan`を実行する。

    3. 開発者はPR上で`plan`の結果を確認し、変更内容をレビューする。

    4. PRが承認され、`main`ブランチにマージされると、Terraform Cloudが自動的に`terraform apply`を実行し、AWS上のインフラ（Lambdaの器、IAMロール、DynamoDBテーブル等）が作成・更新される。
* **エラー処理:** `plan`または`apply`でエラーが発生した場合、Terraform CloudのUI上で実行結果が「失敗」となり、管理者に通知される。

#### 3.3.2. アプリケーションの自動デプロイ (GitHub Actions)

* **処理概要:** `python`ディレクトリ配下のLambdaソースコードやライブラリ定義が`main`ブランチにプッシュされると、GitHub ActionsがLambda関数やレイヤーを個別にビルドし、AWSにデプロイする。
* **トリガー:** GitHub `main`ブランチへの`push`イベント（`python/`配下の変更）
* **処理シーケンス:**
    1. **変更検知:**
        a. `python/requirements.txt`が変更された場合、`Deploy Lambda Layer`ワークフローが起動する。
        b. `python/user_settings_lambda/`配下のファイルが変更された場合、`Deploy user_settings_lambda`ワークフローが起動する。
        c. `python/check_delay_handler/`配下のファイルが変更された場合、`Deploy check_delay_handler`ワークフローが起動する。
    2. **AWS認証:**
        a. GitHub ActionsのOIDC（OpenID Connect）機能を利用し、AWSのIAMロールを引き受けることで、一時的な認証情報を取得する。
    3. **ビルド:**
        a. **Lambdaレイヤー:** `requirements.txt`に基づき、`pip install`でライブラリを特定のディレクトリにインストールし、`zip`ファイルに固める。
        b. **Lambda関数:** 各関数のディレクトリ配下のソースコードを`zip`ファイルに固める。
    4. **デプロイ:**
        a. **Lambdaレイヤー:** AWS CLIの`publish-layer-version`コマンドを実行し、新しいバージョンのレイヤーを発行する。
        b. **Lambda関数:** AWS CLIの`update-function-code`コマンドを実行し、対象のLambda関数のコードを更新する。
* **エラー処理:** ビルドまたはデプロイの各ステップでエラーが発生した場合、GitHub Actionsの実行結果が「失敗」となり、開発者に通知される。

## 4. データ設計

### 4.1. データ永続化設計

#### 4.1.1. DynamoDB: Usersテーブル

* **役割:** ユーザーごとの設定情報を永続的に管理する。
* **テーブル定義:**

| 項目名 | データ型 | 説明 | キー |
| :--- | :--- | :--- | :--- |
| `lineUserId` | String | LINEから取得する一意のユーザーID | パーティションキー |
| `settingOrRoute` | String | 設定項目を示すキー。`#PROFILE#` または路線ID (`odpt:railway`) | ソートキー |

* **グローバルセカンダリインデックス (GSI): `route-index`**
  * **目的:** 路線ID (`settingOrRoute`) からユーザーID (`lineUserId`) を逆引きするために使用する。
  * **定義:**
    * パーティションキー: `settingOrRoute`

#### 4.1.2. S3: キャッシュオブジェクト

* **役割:** Lambda関数間のデータ連携および状態のキャッシュに使用する。
* **オブジェクト一覧:**

| オブジェクトキー | 内容 | 生成・更新タイミング | 利用タイミング |
| :--- | :--- | :--- | :--- |
| `user-list.json` | 設定が更新されたLINEユーザーIDのリスト | `user_settings_lambda` でユーザー設定が保存された際 | `check_delay_handler` の実行時 |
| `delay-messages.json` | 前回通知した遅延情報（路線名とメッセージ）のリスト | `check_delay_handler` で遅延通知を送信した際 | 次回の `check_delay_handler` 実行時（重複通知防止） |

### 4.2. API連携データ設計

* **公共交通オープンデータセンター API (レスポンス例)**
  * フォーマット: JSON
  * 主要な利用項目: `odpt:railway` (路線ID), `odpt:trainInformationText` (詳細テキスト)

* **LINE Messaging API (Push Message Body例)**

```json
{
  "to": "Uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
  "messages": [
    {
      "type": "flex",
      "altText": "JR山手線の運行情報",
      "contents": {
        "type": "bubble",
        "header": {
          "type": "box",
          "layout": "vertical",
          "contents": [
            {
              "type": "text",
              "text": "⚠️ 列車遅延情報",
              "color": "#ffffff",
              "weight": "bold",
              "size": "md"
            }
          ],
          "backgroundColor": "#FF6B6B"
        },
        "body": {
          "type": "box",
          "layout": "vertical",
          "contents": [
            {
              "type": "text",
              "text": "JR山手線",
              "weight": "bold",
              "size": "xl",
              "margin": "md"
            },
            {
              "type": "separator",
              "margin": "lg"
            },
            {
              "type": "box",
              "layout": "vertical",
              "margin": "lg",
              "spacing": "sm",
              "contents": [
                {
                  "type": "text",
                  "text": "○○駅での線路内立入りの影響で、一部列車に15分程度の遅れがでています。",
                  "wrap": true,
                  "color": "#555555",
                  "size": "sm"
                }
              ]
            }
          ]
        }
      }
    }
  ]
}
```

## 5. 非機能要件設計

### セキュリティ

1. LINE Messaging APIのチャネルシークレット、アクセストークン、および公共交通APIのアクセストークンは、AWS Systems Manager パラメータストアまたはAWS Secrets Managerで管理し、Lambda実行時に動的に取得する。
2. 各LambdaにアタッチするIAMロールは、必要最小限の権限（特定のDynamoDBテーブルへのRead/Write、特定のCloudWatch Log GroupへのWriteなど）のみを許可する。

### 保守性・運用

1. APIエンドポイント、DynamoDBテーブル名などの設定値は、Lambdaの環境変数で管理し、コードと分離する。
2. LambdaのログはAmazon CloudWatch LogsにJSON形式で出力し、リクエストID、エラーレベル、メッセージを構造化して記録する。
3. 重大なエラー（DynamoDBアクセス不可など）が発生した場合、CloudWatch Alarmを設定し、Amazon SNS経由で管理者に通知する仕組みを構築する。
4. 路線登録時、Amazon SNS経由で管理者に通知する仕組みを構築する。
